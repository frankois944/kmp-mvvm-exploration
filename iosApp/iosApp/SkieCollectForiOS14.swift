//
//  SkieCollectForiOS14.swift
//  iosApp
//
//  Created by François Dabonot on 08/08/2024.
//  Copyright © 2024 frankois944. All rights reserved.
//

import SwiftUI
@preconcurrency import Shared
import Combine

// An extension of the SwiftUI.View with a compatible iOS 13/14 SKIE `collect` implementation
// It's a copy of the current `collect` implementation of SKIE flow in SwiftUI
// I added a `disposedBy` for managing the lifecycle of the Task correctly
// This way, it sounds like Rx or `Combine` programming
extension SwiftUI.View {

    @MainActor
    func collect<Flow: SkieSwiftFlowProtocol>(flow: Flow,
                                              into binding: SwiftUI.Binding<Flow.Element>,
                                              disposedBy: Binding<Set<AnyCancellable>>) -> some SwiftUI.View {
        collect(flow: flow, disposedBy: disposedBy) { newValue in
            binding.wrappedValue = newValue
        }
    }

    @MainActor
    func collect<Flow: SkieSwiftFlowProtocol, U: Sendable>(
        flow: Flow,
        into binding: SwiftUI.Binding<U>,
        disposedBy: Binding<Set<AnyCancellable>>,
        transform: @escaping (Flow.Element) -> U?
    ) -> some SwiftUI.View {
        collect(flow: flow, disposedBy: disposedBy) { newValue in
            if let newTransformedValue = transform(newValue) {
                binding.wrappedValue = newTransformedValue
            }
        }
    }

    func collect<Flow: SkieSwiftFlowProtocol>(flow: Flow,
                                              disposedBy: Binding<Set<AnyCancellable>>,
                                              perform: @escaping (Flow.Element) -> Swift.Void) -> some SwiftUI.View {
        onAppear {
            /*
             // this is not working on swift6 the flow SkieSwiftFlowProtocol generated by SKIE is not Sendable
             // I can't change it!
             disposedBy.wrappedValue.insert(Task {
             do {
             for try await item in flow {
             #if DEBUG
             print("COLLECTING \(item)")
             #endif
             await perform(item)
             }
             } catch {
             print("error") // or something else
             }
             })
             */
            flow.toPublisher()
                .receive(on: DispatchQueue.main)
                .map { currentValue in
                    return perform(currentValue)
                }
                .sink { newValue in
                    #if DEBUG
                    print("COLLECTING \(newValue)")
                    #endif
                }
                .store(in: &disposedBy.wrappedValue)
        }
    }
}
